using System;
using System.Net;
using System.Text.RegularExpressions;
using Content.Client.UserInterface.MainMenu;
using Robust.Client;
using Robust.Client.AutoGenerated;
using Robust.Client.Console;
using Robust.Client.Graphics;
using Robust.Client.State;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared;
using Robust.Shared.AuthLib;
using Robust.Shared.Configuration;
using Robust.Shared.ContentPack;
using Robust.Shared.IoC;
using Robust.Shared.Localization;
using Robust.Shared.Log;
using Robust.Shared.Network;
using Robust.Shared.Utility;

namespace Content.Client.UserInterface.ConnectionScreen;

[GenerateTypedNameReferences]
public sealed partial class ConnectionScreen : UIScreen
{
    [Dependency] private readonly IBaseClient _client = default!;
    [Dependency] private readonly IConfigurationManager _cfg = default!;
    [Dependency] private readonly IUserInterfaceManager _userInterface = default!;
    [Dependency] private readonly IClientNetManager _net = default!;
    [Dependency] private readonly IClientConsoleHost _console = default!;
    [Dependency] private readonly IGameController _game = default!;

    // ReSharper disable once InconsistentNaming
    private static readonly Regex IPv6Regex = new(@"\[(.*:.*:.*)](?::(\d+))?");

    private bool _isConnecting = false;

    private ISawmill _sawmill = default!;
    public const string SawmillId = "interface.connectionscreen";

    public ConnectionScreen()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        SetAnchorPreset(this, LayoutPreset.Wide);

        SetAnchorPreset(ConnectionBox, LayoutPreset.TopRight);
        SetMarginRight(ConnectionBox, -25);
        SetMarginTop(ConnectionBox, 30);
        SetGrowHorizontal(ConnectionBox, GrowDirection.Begin);

        Tittle.Text = _game.GameTitle();
        UsernameEdit.Text = _cfg.GetCVar(CVars.PlayerName);
        _client.RunLevelChanged += RunLevelChanged;

        ConnectButton.OnPressed += ConnectButtonOnOnPressed;
        QuitButton.OnPressed += _ => _console.ExecuteCommand("quit"); // is not a void
    }

    private void ConnectButtonOnOnPressed(BaseButton.ButtonEventArgs obj)
    {
        var inputName = UsernameEdit.Text.Trim();
        var configName = _cfg.GetCVar(CVars.PlayerName);
        Status.Text = "Validating username...";

        if (!UsernameHelpers.IsNameValid(inputName, out var reason))
        {
            var invalidReason = Loc.GetString(reason.ToText());
            _userInterface.Popup(
                Loc.GetString("debug-builtin-connection-screen-invalid-username-with-reason", ("invalidReason", invalidReason)),
                Loc.GetString("debug-builtin-connection-screen-invalid-username"));

            Status.Text = "Invalid username!";
            return;
        }
        Status.Text = "Connecting to the server...";

        if (UsernameEdit.Text != configName)
        {
            _cfg.SetCVar(CVars.PlayerName, inputName);
            _cfg.SaveToFile();
        }

        SetConnectingState(true);
        _net.ConnectFailed += OnConnectFailed;

        try
        {
            ParseAddress(ConnectionAddress.Text, out var ip, out var port);
            _client.ConnectToServer(ip, port);
        }
        catch (ArgumentException e)
        {
            _userInterface.Popup(Loc.GetString("debug-builtin-connection-screen-failed-to-connect", ("reason", e.Message)));
            _sawmill.Warning(e.ToString());
            _net.ConnectFailed -= OnConnectFailed;
            SetConnectingState(false);
            Status.Text = "Fail!";
        }
    }

    private void ParseAddress(string address, out string ip, out ushort port)
    {
        var match6 = IPv6Regex.Match(address);
        if (match6 != Match.Empty)
        {
            ip = match6.Groups[1].Value;
            if (!match6.Groups[2].Success)
            {
                port = _client.DefaultPort;
            }
            else if (!ushort.TryParse(match6.Groups[2].Value, out port))
            {
                throw new ArgumentException("Not a valid port.");
            }

            return;
        }

        // See if the IP includes a port.
        var split = address.Split(':');
        ip = address;
        port = _client.DefaultPort;
        if (split.Length > 2)
        {
            throw new ArgumentException("Not a valid Address.");
        }

        // IP:port format.
        if (split.Length == 2)
        {
            ip = split[0];
            if (!ushort.TryParse(split[1], out port))
            {
                throw new ArgumentException("Not a valid port.");
            }
        }
    }

    private void RunLevelChanged(object? obj, RunLevelChangedEventArgs args)
    {
        switch (args.NewLevel)
        {
            case ClientRunLevel.Connecting:
                SetConnectingState(true);
                break;
            case ClientRunLevel.Connected:
                SetConnectingState(false);
                Status.Text = "Success!";
                var stateManager = IoCManager.Resolve<IStateManager>().RequestStateChange<MainMenuState>();
                _net.ConnectFailed -= OnConnectFailed;
                break;
        }
    }

    private void OnConnectFailed(object? _, NetConnectFailArgs args)
    {
        _userInterface.Popup(Loc.GetString("debug-builtin-connection-screen-failed-to-connect",("reason", args.Reason)));
        _net.ConnectFailed -= OnConnectFailed;
        SetConnectingState(false);
    }

    private void SetConnectingState(bool state)
    {
        _isConnecting = state;
        ConnectButton.Disabled = state;
    }
}
